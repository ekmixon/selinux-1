#!/usr/bin/python3 -E


from __future__ import print_function
import os
import errno
import shutil
import sys
from optparse import OptionParser


try:
    import selinux
    import semanage
except ImportError:
    print("You must install libselinux-python and libsemanage-python before running this tool", file=sys.stderr)
    exit(1)


def copy_file(src, dst):
    if DEBUG:
        print(f"copying {src} to {dst}")
    try:
        shutil.copy(src, dst)
    except OSError as the_err:
        (err, strerr) = the_err.args
        print(f"Could not copy {src} to {dst}, {strerr}", file=sys.stderr)
        exit(1)


def create_dir(dst, mode):
    if DEBUG:
        print(f"Making directory {dst}")
    try:
        os.makedirs(dst, mode)
    except OSError as the_err:
        (err, stderr) = the_err.args
        if err != errno.EEXIST:
            print(f"Error creating {dst}", file=sys.stderr)
            exit(1)


def create_file(dst):
    if DEBUG:
        print(f"Making file {dst}")
    try:
        open(dst, 'a').close()
    except OSError as the_err:
        (err, stderr) = the_err.args
        print(f"Error creating {dst}", file=sys.stderr)
        exit(1)


def copy_module(store, name, base):
    if DEBUG:
        print(f"Install module {name}")
    (file, ext) = os.path.splitext(name)
    if ext != ".pp":
        # Stray non-pp file in modules directory, skip
        print(f"warning: {name} has invalid extension, skipping", file=sys.stderr)
        return
    try:
        root = oldstore_path(store) if base else oldmodules_path(store)
        bottomdir = bottomdir_path(store)

        os.mkdir(f"{bottomdir}/{file}")

        copy_file(os.path.join(root, name), f"{bottomdir}/{file}/hll")

        with open(f"{bottomdir}/{file}/lang_ext", "w+", 0o600) as efile:
            efile.write("pp")
    except (IOError, OSError):
        print(f"Error installing module {name}", file=sys.stderr)
        exit(1)


def disable_module(file, name, disabledmodules):
    if DEBUG:
        print(f"Disabling {name}")
    (disabledname, disabledext) = os.path.splitext(file)
    create_file(f"{disabledmodules}/{disabledname}")


def migrate_store(store):
    oldstore = oldstore_path(store)
    oldmodules = oldmodules_path(store)
    disabledmodules = disabledmodules_path(store)
    newstore = newstore_path(store)
    newmodules = newmodules_path(store)
    bottomdir = bottomdir_path(store)

    print(f"Migrating from {oldstore} to {newstore}")

    # Build up new directory structure
    create_dir(f"{newroot_path()}/{store}", 0o755)
    create_dir(newstore, 0o700)
    create_dir(newmodules, 0o700)
    create_dir(bottomdir, 0o700)
    create_dir(disabledmodules, 0o700)

    # Special case for base since it was in a different location
    copy_module(store, "base.pp", 1)

    # Dir structure built, start copying files
    for root, dirs, files in os.walk(oldstore):
        if root == oldstore:
            # This is the top level directory, need to move
            for name in files:
                # Check to see if it is in TOPPATHS and copy if so
                if name in TOPPATHS:
                    newname = "seusers.local" if name == "seusers" else name
                    copy_file(os.path.join(root, name), os.path.join(newstore, newname))

        elif root == oldmodules:
            # This should be the modules directory
            for name in files:
                (file, ext) = os.path.splitext(name)
                if name == "base.pp":
                    print(
                        f"Error installing module {name}, name conflicts with base",
                        file=sys.stderr,
                    )

                    exit(1)
                elif ext == ".disabled":
                    disable_module(file, name, disabledmodules)
                else:
                    copy_module(store, name, 0)


def rebuild_policy():
    # Ok, the modules are loaded, lets try to rebuild the policy
    print(f"Attempting to rebuild policy from {newroot_path()}")

    curstore = selinux.selinux_getpolicytype()[1]

    handle = semanage.semanage_handle_create()
    if not handle:
        print("Could not create semanage handle", file=sys.stderr)
        exit(1)

    semanage.semanage_select_store(handle, curstore, semanage.SEMANAGE_CON_DIRECT)

    if not semanage.semanage_is_managed(handle):
        semanage.semanage_handle_destroy(handle)
        print("SELinux policy is not managed or store cannot be accessed.", file=sys.stderr)
        exit(1)

    rc = semanage.semanage_access_check(handle)
    if rc < semanage.SEMANAGE_CAN_WRITE:
        semanage.semanage_handle_destroy(handle)
        print("Cannot write to policy store.", file=sys.stderr)
        exit(1)

    rc = semanage.semanage_connect(handle)
    if rc < 0:
        semanage.semanage_handle_destroy(handle)
        print("Could not establish semanage connection", file=sys.stderr)
        exit(1)

    semanage.semanage_set_rebuild(handle, 1)

    rc = semanage.semanage_begin_transaction(handle)
    if rc < 0:
        semanage.semanage_handle_destroy(handle)
        print("Could not begin transaction", file=sys.stderr)
        exit(1)

    rc = semanage.semanage_commit(handle)
    if rc < 0:
        print("Could not commit transaction", file=sys.stderr)

    semanage.semanage_handle_destroy(handle)


def oldroot_path():
    return f"{ROOT}/etc/selinux"


def oldstore_path(store):
    return f"{oldroot_path()}/{store}/modules/active"


def oldmodules_path(store):
    return f"{oldstore_path(store)}/modules"


def disabledmodules_path(store):
    return f"{newmodules_path(store)}/disabled"


def newroot_path():
    return f"{ROOT}{PATH}"


def newstore_path(store):
    return f"{newroot_path()}/{store}/active"


def newmodules_path(store):
    return f"{newstore_path(store)}/modules"


def bottomdir_path(store):
    return f"{newmodules_path(store)}/{PRIORITY}"


if __name__ == "__main__":

    parser = OptionParser()
    parser.add_option("-p", "--priority", dest="priority", default="100",
                      help="Set priority of modules in new store (default: 100)")
    parser.add_option("-s", "--store", dest="store", default=None,
                      help="Store to read from and write to")
    parser.add_option("-d", "--debug", dest="debug", action="store_true", default=False,
                      help="Output debug information")
    parser.add_option("-c", "--clean", dest="clean", action="store_true", default=False,
                      help="Clean old modules directory after migrate (default: no)")
    parser.add_option("-n", "--norebuild", dest="norebuild", action="store_true", default=False,
                      help="Disable rebuilding policy after migration (default: no)")
    parser.add_option("-P", "--path", dest="path",
                      help="Set path for the policy store (default: /var/lib/selinux)")
    parser.add_option("-r", "--root", dest="root",
                      help="Set an alternative root for the migration (default: /)")

    (options, args) = parser.parse_args()

    DEBUG = options.debug
    PRIORITY = options.priority
    TYPE = options.store
    CLEAN = options.clean
    NOREBUILD = options.norebuild
    PATH = options.path
    if PATH is None:
        PATH = "/var/lib/selinux"

    ROOT = options.root
    if ROOT is None:
        ROOT = ""

    # List of paths that go in the active 'root'
    TOPPATHS = [
        "commit_num",
        "ports.local",
        "interfaces.local",
        "nodes.local",
        "booleans.local",
        "file_contexts.local",
        "seusers",
        "users.local",
        "users_extra",
        "users_extra.local",
        "disable_dontaudit",
        "preserve_tunables",
        "policy.kern",
        "file_contexts",
        "homedir_template",
        "pkeys.local",
        "ibendports.local"]

    create_dir(newroot_path(), 0o755)

    stores = None
    if TYPE is not None:
        stores = [TYPE]
    else:
        stores = os.listdir(oldroot_path())

    # find stores in oldroot and migrate them to newroot if necessary
    for store in stores:
        if not os.path.isdir(oldmodules_path(store)):
            # already migrated or not an selinux store
            continue

        if os.path.isdir(newstore_path(store)):
            # store has already been migrated, but old modules dir still exits
            print("warning: Policy type %s has already been migrated, but modules still exist in the old store. Skipping store." % store, file=sys.stderr)
            continue

        migrate_store(store)

        if CLEAN is True:
            def remove_error(function, path, execinfo):
                print(
                    f"warning: Unable to remove old store modules directory {oldmodules_path(store)}. Cleaning failed.",
                    file=sys.stderr,
                )
            shutil.rmtree(oldmodules_path(store), onerror=remove_error)

    if NOREBUILD is False:
        rebuild_policy()
